{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveDataTypeable #-}

module Raft.Protocol 
( initRaft
)
where

import System.Environment
import System.Console.ANSI
import System.Exit
import System.Posix.Signals
import Control.Concurrent 
import Control.Monad 
import Control.Applicative
import Control.Distributed.Process
import Control.Distributed.Process.Node hiding (newLocalNode)
import Control.Distributed.Process.Backend.SimpleLocalnet
import Control.Distributed.Process.Serializable
import Text.Printf
import Data.Binary
import Data.Typeable
import GHC.Generics (Generic)

-- | Type renaming to make things clearer.
type Term = Int
type Index = Int
type ServerId = Int
type Log a = [LogEntry a]

data ServerRole = Follower | Candidate | Leader deriving (Show, Read, Eq)

-- | Wrapper around state transition rule. Derive Typeable and Binary
-- so that we can serialize it.
newtype Command a = Command a deriving (Show, Read, Eq, Typeable)

instance (Binary a) => Binary (Command a) where
    put (Command a) = put a
    get = get >>= \a -> return (Command a)

-- | An entry in a log, clearly. Also serializable.
data LogEntry a = LogEntry 
    { index          :: Index
    , termReceived   :: Term
    , committed      :: Bool
    , command        :: Command a
    } deriving (Show, Read, Eq, Typeable)

instance (Binary a) => Binary (LogEntry a) where
    put (LogEntry a b c d) = put a >> put b >> put c >> put d
    get = do
        a <- get
        b <- get
        c <- get
        d <- get
        return $ LogEntry a b c d

-- | One of two RPC calls from the Raft paper, implemented here as 
-- pairs of sends and receives matched by sequence number, for lack
-- of good RPC support in Haskell.
appendEntries :: (Serializable a) 
              => ( ProcessId    -- ^ Sender's process id
                 , Int          -- ^ Sequence number, for matching replies
                 , Term         -- ^ Leader's term
                 , NodeId       -- ^ Leader's Id
                 , Index        -- ^ Log entry index right before new ones
                 , Term         -- ^ Term of the previous log entry
                 , Log a        -- ^ Log entries to store, [] for heartbeat
                 , Index)       -- ^ Leader's commit index
                 -> Process ()
appendEntries ( sender          
              , seqno
              , term
              , leaderId
              , prevLogIndex
              , prevLogTerm
              , entries
              , leaderCommit) = send sender "DUMMY"

-- | A response generated by making a call to appendEntries.
appendEntriesResponse :: ( ProcessId -- ^ Sender's process id
                         , Int       -- ^ Sequence number, for matching replies
                         , Term      -- ^ Current term to update leader
                         , Bool)     -- ^ Did follower contain a matching entry?
                         -> Process ()
appendEntriesResponse (sender, seqno, term, success) = say "DUMMY"

-- | Two of two RPC calls from the Raft paper, implemented here as
-- pairs of sends and receives matched by sequence number, for lack
-- of good RPC support in Haskell.
requestVote :: ( ProcessId      -- ^ Sender's process id
               , Int            -- ^ Sequence number, for matching replies
               , Term           -- ^ Candidate's term
               , NodeId         -- ^ Candidate requesting vote
               , Index          -- ^ Index of candidate's last log entry
               , Term)          -- ^ Term of candidate's last log entry
               -> Process ()
requestVote ( sender
            , seqno
            , term
            , candidateId
            , lastLogIndex
            , lastLogTerm) = send sender "DUMMY"

-- | A response generated by making a call to requestVote.
requestVoteResponse :: ( ProcessId -- ^ Sender's process id
                       , Int       -- ^ Sequence number, for matching replies
                       , Term      -- ^ Current term to update leader
                       , Bool)     -- ^ Did candidate receive vote?
                       -> Process ()
requestVoteResponse (sender, seqno, term, voteGranted) = say "DUMMY"


initRaft :: Backend -> [LocalNode] -> Process ()
initRaft backend nodes = return ()
